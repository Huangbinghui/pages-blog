import{_ as t,c as d,o as a,a2 as e,a3 as r,a4 as s,a5 as n,a6 as i,a7 as o}from"./chunks/framework.ClDkF6YQ.js";const I=JSON.parse('{"title":"存储层次和原理","description":"","frontmatter":{},"headers":[],"relativePath":"articles/CS/pg/存储管理.md","filePath":"articles/CS/pg/存储管理.md"}'),l={name:"articles/CS/pg/存储管理.md"},h=e('<h1 id="存储层次和原理" tabindex="-1">存储层次和原理 <a class="header-anchor" href="#存储层次和原理" aria-label="Permalink to &quot;存储层次和原理&quot;">​</a></h1><p><img src="'+r+'" alt="img"></p><h1 id="页面和元组" tabindex="-1">页面和元组 <a class="header-anchor" href="#页面和元组" aria-label="Permalink to &quot;页面和元组&quot;">​</a></h1><p>一般来说，数据表数据物理存储在非易失性存储设备上面，PG也不例外。如下图所示，数据表中的数据存储在N个数据文件中，每个数据文件有N个Page（大小默认为8K，可在编译安装时指定）组成。Page为PG的最小存取单元。</p><p><img src="'+s+'" alt="bb"></p><p><img src="'+n+'" alt="image-20221124164842748"></p><img src="'+i+'" alt="image-20221124165242489" style="zoom:50%;"><p><strong>总体页面布局</strong></p><table><thead><tr><th>项</th><th>描述</th></tr></thead><tbody><tr><td>PageHeaderData</td><td>24字节长。包含关于页面的一般信息，包括空闲空间指针。</td></tr><tr><td>ItemIdData</td><td>指向实际项的项标识符数组。每一个条目是一对(偏移量、长度)。每个项 4 字节。</td></tr><tr><td>Free space</td><td>未分配的空间（空闲空间）。新项标识符从这个区域的开头开始分配，新项从其结尾开始分配。</td></tr><tr><td>Items</td><td>实际的项本身。</td></tr><tr><td>Special space</td><td>索引访问模式相关的数据。不同的索引访问方式存放不同的数据。在普通表中为空。</td></tr></tbody></table><p><strong>PageHeaderData布局</strong></p><table><thead><tr><th>域</th><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>pd_lsn</td><td>PageXLogRecPtr</td><td>8 bytes</td><td>LSN: 最后修改这个页面的WAL记录最后一个字节后面的第一个字节</td></tr><tr><td>pd_checksum</td><td>uint16</td><td>2 bytes</td><td>页面校验码</td></tr><tr><td>pd_flags</td><td>uint16</td><td>2 bytes</td><td>标志位</td></tr><tr><td>pd_lower</td><td>LocationIndex</td><td>2 bytes</td><td>到空闲空间开头的偏移量</td></tr><tr><td>pd_upper</td><td>LocationIndex</td><td>2 bytes</td><td>到空闲空间结尾的偏移量</td></tr><tr><td>pd_special</td><td>LocationIndex</td><td>2 bytes</td><td>到特殊空间开头的偏移量</td></tr><tr><td>pd_pagesize_version</td><td>uint16</td><td>2 bytes</td><td>页面大小和布局版本号信息</td></tr><tr><td>pd_prune_xid</td><td>TransactionId</td><td>4 bytes</td><td>页面上最老未删除XMAX，如果没有则为0</td></tr></tbody></table><p><strong>HeapTupleHeaderData布局</strong></p><table><thead><tr><th>域</th><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>t_xmin</td><td>TransactionId</td><td>4 bytes</td><td>插入XID标志</td></tr><tr><td>t_xmax</td><td>TransactionId</td><td>4 bytes</td><td>删除XID标志</td></tr><tr><td>t_cid</td><td>CommandId</td><td>4 bytes</td><td>插入和/或删除CID标志（覆盖t_xvac）</td></tr><tr><td>t_xvac</td><td>TransactionId</td><td>4 bytes</td><td>VACUUM操作移动一个行版本的XID</td></tr><tr><td>t_ctid</td><td>ItemPointerData</td><td>6 bytes</td><td>当前版本的TID或者指向更新的行版本</td></tr><tr><td>t_infomask2</td><td>uint16</td><td>2 bytes</td><td>一些属性，加上多个标志位</td></tr><tr><td>t_infomask</td><td>uint16</td><td>2 bytes</td><td>多个标志位</td></tr><tr><td>t_hoff</td><td>uint8</td><td>1 byte</td><td>到用户数据的偏移量</td></tr></tbody></table><h1 id="buffer-manager" tabindex="-1">Buffer Manager <a class="header-anchor" href="#buffer-manager" aria-label="Permalink to &quot;Buffer Manager&quot;">​</a></h1><p>Buffer Manager管理着共享内存和磁盘之间传输数据，对DBMS的性能有着至关重要的影响。</p><p>本文描述PG的Buffer Manager。第一部分为概述，其它部分讨论了如下话题：</p><ul><li>Buffer Manager结构</li><li>Buffer Manager锁</li><li>Buffer Manager如何运行</li><li>Buffer环</li><li>脏页落盘</li></ul><h2 id="buffer-manager结构" tabindex="-1">Buffer Manager结构 <a class="header-anchor" href="#buffer-manager结构" aria-label="Permalink to &quot;Buffer Manager结构&quot;">​</a></h2><h3 id="buffer-manager结构-1" tabindex="-1">Buffer Manager结构 <a class="header-anchor" href="#buffer-manager结构-1" aria-label="Permalink to &quot;Buffer Manager结构&quot;">​</a></h3><p><img src="'+o+'" alt="Fig. 8.3. Buffer manager&#39;s three-layer structure."></p>',20),_=[h];function p(c,f,u,b,g,m){return a(),d("div",null,_)}const P=t(l,[["render",p]]);export{I as __pageData,P as default};
