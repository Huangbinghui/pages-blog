import{_ as a,c as e,o as l,a2 as o,a8 as t}from"./chunks/framework.ClDkF6YQ.js";const b=JSON.parse('{"title":"GC依据","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Java/GC.md","filePath":"articles/Java/GC.md"}'),i={name:"articles/Java/GC.md"},r=o('<h1 id="gc依据" tabindex="-1">GC依据 <a class="header-anchor" href="#gc依据" aria-label="Permalink to &quot;GC依据&quot;">​</a></h1><h2 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h2><p>每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 <strong>null</strong> 时，引用计数减 1。</p><p>缺点：</p><ul><li>对象循环引用时，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。</li></ul><h2 id="可达性分析法" tabindex="-1">可达性分析法 <a class="header-anchor" href="#可达性分析法" aria-label="Permalink to &quot;可达性分析法&quot;">​</a></h2><h1 id="gc方式" tabindex="-1">GC方式 <a class="header-anchor" href="#gc方式" aria-label="Permalink to &quot;GC方式&quot;">​</a></h1><ol><li>停止-复制</li><li>标记-清除</li><li>分代</li><li>自适应</li></ol><h2 id="停止-复制" tabindex="-1">停止-复制 <a class="header-anchor" href="#停止-复制" aria-label="Permalink to &quot;停止-复制&quot;">​</a></h2><p>程序首先停止，然后把存活的对象从一个堆复制到另一个堆，剩下的就是“垃圾”。当对象移动时，所有指向该对象的引用都要修改。</p><p>缺点：</p><ul><li>需要有两个堆，内存需求打了一倍。</li><li>程序一旦变得稳定就很少有垃圾产生，来回复制浪费资源。</li></ul><h2 id="标记-清除" tabindex="-1">标记-清除 <a class="header-anchor" href="#标记-清除" aria-label="Permalink to &quot;标记-清除&quot;">​</a></h2><p>从栈和静态存储开始，遍历所有引用以查找存活的对象。每找到一个存活的对象都设置一个标志，标记完成后开始清除。</p><p>缺点：</p><ul><li><p>速度慢，只有垃圾少的时候速度快。</p><h2 id="分代" tabindex="-1">分代 <a class="header-anchor" href="#分代" aria-label="Permalink to &quot;分代&quot;">​</a></h2></li></ul><p>创建一个对象时，总是在Eden区操作，当这个区满了，那么就会触发一次Young GC，也就是年轻代的垃圾回收。</p><p>当Eden区再次被用完，就再触发一次Young GC，此时会将Eden区与From区还在被使用的对象复制到To区。</p><p>在下一次Young GC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。</p><p>若干次Young GC后，有些对象在From与To之间来回游荡，一旦超出阈值，就将它们复制到老年代。如果老年代被用完，则执行Full GC。</p><img src="'+t+'" alt="image-20230316213131707" style="zoom:50%;"><h2 id="自适应" tabindex="-1">自适应 <a class="header-anchor" href="#自适应" aria-label="Permalink to &quot;自适应&quot;">​</a></h2><p>JVM会监控垃圾收集的效率，如果所有对象都很稳定，垃圾收集器效率很低的话，它会切换到“标记 – 清除”算法。同样，JVM会跟踪标记和清除的效果，如果堆里开始出现很多碎片，它会切换回“停止 – 复制”算法。</p><h1 id="资源清理" tabindex="-1">资源清理 <a class="header-anchor" href="#资源清理" aria-label="Permalink to &quot;资源清理&quot;">​</a></h1><h2 id="finalize-方法" tabindex="-1">finalize()方法 <a class="header-anchor" href="#finalize-方法" aria-label="Permalink to &quot;finalize()方法&quot;">​</a></h2><blockquote><p>假设你的对象在<strong>不使用</strong> <strong>new</strong> 的情况下分配了一块“特殊”内存(例：JNDI)。垃圾收集器只知道如何释放由 new 分配的内存，所以它不知道如何释放对象的这块“特殊”内存。</p></blockquote>',26),n=[r];function h(s,c,d,u,p,_){return l(),e("div",null,n)}const f=a(i,[["render",h]]);export{b as __pageData,f as default};
